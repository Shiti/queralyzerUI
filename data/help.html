<p>
    The <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement provides
    information about the execution plan for a
    <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement.
</p><p>
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> returns a row of
    information for each table used in the
    <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement. It lists the
    tables in the output in the order that MySQL would read them
    while processing the statement. MySQL resolves all joins using a
    nested-loop join method. This means that MySQL reads a row from
    the first table, and then finds a matching row in the second
    table, the third table, and so on. When all tables are
    processed, MySQL outputs the selected columns and backtracks
    through the table list until a table is found for which there
    are more matching rows. The next row is read from this table and
    the process continues with the next table.
</p><p>
    When the <code class="literal">EXTENDED</code> keyword is used,
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces extra
    information that can be viewed by issuing a
    <a class="link"  title="13.7.5.41. SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> statement following
    the <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement.
    <a class="link" title="8.8.3. EXPLAIN EXTENDED Output Format"><code class="literal">EXPLAIN EXTENDED</code></a> also displays
    the <code class="literal">filtered</code> column. See
    <a class="xref" title="8.8.3. EXPLAIN EXTENDED Output Format">Section 8.8.3, “<code class="literal">EXPLAIN EXTENDED</code> Output Format”</a>.
</p>
<div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

    <div class="admon-title">
        Note
    </div>
    <p xmlns="">
        You cannot use the <code class="literal">EXTENDED</code> and
        <code class="literal">PARTITIONS</code> keywords together in the same
        <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement.
    </p>
</div>
<div class="itemizedlist">
    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="#explain-output-columns" title="8.8.2.  ???TITLE??? Output Columns"><code class="literal">EXPLAIN</code>
            Output Columns</a>
    </p></li><li class="listitem"><p>
        <a class="link" href="#explain-join-types" title="8.8.2.  ???TITLE??? Join Types"><code class="literal">EXPLAIN</code>
            Join Types</a>
    </p></li><li class="listitem"><p>
        <a class="link" href="#explain-extra-information" title="8.8.2.  ???TITLE??? Extra Information"><code class="literal">EXPLAIN</code>
            Extra Information</a>
    </p></li><li class="listitem"><p>
        <a class="link" href="#explain-output-interpretation" title="8.8.2.  ???TITLE??? Output Interpretation"><code class="literal">EXPLAIN</code>
            Output Interpretation</a>
    </p></li></ul>
</div>
<h4><a name="explain-output-columns"></a>
    <code class="literal">EXPLAIN</code> Output Columns
</h4>
<p>
    This section describes the output columns produced by
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. Later sections provide
    additional information about the
    <a class="link" href="#explain-join-types" title="8.8.2.  ???TITLE??? Join Types"><code class="literal">type</code></a>
    and
    <a class="link" href="#explain-extra-information" title="8.8.2.  ???TITLE??? Extra Information"><code class="literal">Extra</code></a>
    columns.
</p><p>
    Each output row from <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
    provides information about one table. Each row contains the
    values summarized in
    <a class="xref" href="#explain-output-column-table" title="Table 8.1. EXPLAIN Output Columns">Table 8.1, “<code class="literal">EXPLAIN</code> Output Columns”</a>, and described in
    more detail following the table.
</p>
<div class="table">
    <a name="explain-output-column-table"></a><p class="title"><b>Table 8.1. <code class="literal">EXPLAIN</code> Output Columns</b></p>
    <div class="table-contents">
        <table summary="EXPLAIN Output Columns" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Column</th><th scope="col">Meaning</th></tr></thead><tbody><tr><td scope="row"><a class="link" href="#explain_id"><code class="literal">id</code></a></td><td>The <code class="literal">SELECT</code> identifier</td></tr><tr><td scope="row"><a class="link" href="#explain_select_type"><code class="literal">select_type</code></a></td><td>The <code class="literal">SELECT</code> type</td></tr><tr><td scope="row"><a class="link" href="#explain_table"><code class="literal">table</code></a></td><td>The table for the output row</td></tr><tr><td scope="row"><a class="link" href="#explain_partitions"><code class="literal">partitions</code></a></td><td>The matching partitions</td></tr><tr><td scope="row"><a class="link" href="#explain_type"><code class="literal">type</code></a></td><td>The join type</td></tr><tr><td scope="row"><a class="link" href="#explain_possible_keys"><code class="literal">possible_keys</code></a></td><td>The possible indexes to choose</td></tr><tr><td scope="row"><a class="link" href="#explain_key"><code class="literal">key</code></a></td><td>The index actually chosen</td></tr><tr><td scope="row"><a class="link" href="#explain_key_len"><code class="literal">key_len</code></a></td><td>The length of the chosen key</td></tr><tr><td scope="row"><a class="link" href="#explain_ref"><code class="literal">ref</code></a></td><td>The columns compared to the index</td></tr><tr><td scope="row"><a class="link" href="#explain_rows"><code class="literal">rows</code></a></td><td>Estimate of rows to be examined</td></tr><tr><td scope="row"><a class="link" href="#explain_filtered"><code class="literal">filtered</code></a></td><td>Percentage of rows filtered by table condition</td></tr><tr><td scope="row"><a class="link" href="#explain_extra"><code class="literal">Extra</code></a></td><td>Additional information</td></tr></tbody></table>
    </div>

</div>
<br class="table-break">
<div class="itemizedlist">
    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="explain_id"></a>
        <code class="literal">id</code>
    </p><p>
        The <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> identifier. This
        is the sequential number of the
        <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> within the query. The
        value can be <code class="literal">NULL</code> if the row refers to
        the union result of other rows. In this case, the
        <code class="literal">table</code> column shows a value like
        <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>
        to indicate that the row refers to the union of the rows
        with <code class="literal">id</code> values of
        <em class="replaceable"><code>M</code></em> and
        <em class="replaceable"><code>N</code></em>.
    </p></li><li class="listitem"><p><a name="explain_select_type"></a>
        <code class="literal">select_type</code>
    </p><p>
        The type of <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>, which can
        be any of those shown in the following table.
    </p>
        <div class="informaltable">
            <table summary="This table lists select_type
              values and describes the meaning of each." border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><code class="literal">select_type</code> Value</th><th scope="col">Meaning</th></tr></thead><tbody><tr><td scope="row"><code class="literal">SIMPLE</code></td><td>Simple <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> (not using
                <a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a> or subqueries)</td></tr><tr><td scope="row"><code class="literal">PRIMARY</code></td><td>Outermost <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a></td></tr><tr><td scope="row"><a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a></td><td>Second or later <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement in a
                <a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a></td></tr><tr><td scope="row"><code class="literal">DEPENDENT UNION</code></td><td>Second or later <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement in a
                <a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a>, dependent on
                outer query</td></tr><tr><td scope="row"><code class="literal">UNION RESULT</code></td><td>Result of a <a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a>.</td></tr><tr><td scope="row"><code class="literal">SUBQUERY</code></td><td>First <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> in subquery</td></tr><tr><td scope="row"><code class="literal">DEPENDENT SUBQUERY</code></td><td>First <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> in subquery, dependent on
                outer query</td></tr><tr><td scope="row"><code class="literal">DERIVED</code></td><td>Derived table <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> (subquery in
                <code class="literal">FROM</code> clause)</td></tr><tr><td scope="row"><code class="literal">UNCACHEABLE SUBQUERY</code></td><td>A subquery for which the result cannot be cached and must be
                re-evaluated for each row of the outer query</td></tr><tr><td scope="row"><code class="literal">UNCACHEABLE UNION</code></td><td>The second or later select in a <a class="link" title="13.2.9.4. UNION Syntax"><code class="literal">UNION</code></a>
                that belongs to an uncacheable subquery (see
                <code class="literal">UNCACHEABLE SUBQUERY</code>)</td></tr></tbody></table>
        </div>
        <p>
            <code class="literal">DEPENDENT</code> typically signifies the use of
            a correlated subquery. See
            <a class="xref"  title="13.2.10.7. Correlated Subqueries">Section 13.2.10.7, “Correlated Subqueries”</a>.
        </p><p>
            <code class="literal">DEPENDENT SUBQUERY</code> evaluation differs
            from <code class="literal">UNCACHEABLE SUBQUERY</code> evaluation. For
            <code class="literal">DEPENDENT SUBQUERY</code>, the subquery is
            re-evaluated only once for each set of different values of
            the variables from its outer context. For
            <code class="literal">UNCACHEABLE SUBQUERY</code>, the subquery is
            re-evaluated for each row of the outer context.
        </p><p>
            Cacheability of subqueries differs from caching of query
            results in the query cache (which is described in
            <a class="xref" href="query-cache-operation.html" title="8.9.3.1. How the Query Cache Operates">Section 8.9.3.1, “How the Query Cache Operates”</a>). Subquery caching
            occurs during query execution, whereas the query cache is
            used to store results only after query execution finishes.
        </p></li><li class="listitem"><p><a name="explain_table"></a>
        <code class="literal">table</code>
    </p><p>
        The name of the table to which the row of output refers.
        This can also be one of the following values:
    </p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>:
                The row refers to the union of the rows with
                <code class="literal">id</code> values of
                <em class="replaceable"><code>M</code></em> and
                <em class="replaceable"><code>N</code></em>.
            </p></li><li class="listitem"><p>
                <code class="literal">&lt;derived<em class="replaceable"><code>N</code></em>&gt;</code>:
                The row refers to the derived table result for the row
                with an <code class="literal">id</code> value of
                <em class="replaceable"><code>N</code></em>. A derived table may
                result, for example, from a subquery in the
                <code class="literal">FROM</code> clause.
            </p></li></ul>
        </div>
    </li><li class="listitem"><p><a name="explain_partitions"></a>
        <code class="literal">partitions</code>
    </p><p>
        The partitions from which records would be matched by the
        query. This column is displayed only if the
        <code class="literal">PARTITIONS</code> keyword is used. The value is
        <code class="literal">NULL</code> for nonpartitioned tables. See
        <a class="xref" href="partitioning-info.html" title="18.3.4. Obtaining Information About Partitions">Section 18.3.4, “Obtaining Information About Partitions”</a>.
    </p></li><li class="listitem"><p><a name="explain_type"></a>
        <code class="literal">type</code>
    </p><p>
        The join type. For descriptions of the different types, see
        <a class="link" href="#explain-join-types" title="8.8.2.  ???TITLE??? Join Types"><code class="literal">EXPLAIN</code>
            Join Types</a>.
    </p></li><li class="listitem"><p><a name="explain_possible_keys"></a>
        <code class="literal">possible_keys</code>
    </p><p>
        The <code class="literal">possible_keys</code> column indicates which
        indexes MySQL can choose from use to find the rows in this
        table. Note that this column is totally independent of the
        order of the tables as displayed in the output from
        <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. That means that some
        of the keys in <code class="literal">possible_keys</code> might not be
        usable in practice with the generated table order.
    </p><p>
        If this column is <code class="literal">NULL</code>, there are no
        relevant indexes. In this case, you may be able to improve
        the performance of your query by examining the
        <code class="literal">WHERE</code> clause to check whether it refers
        to some column or columns that would be suitable for
        indexing. If so, create an appropriate index and check the
        query with <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> again. See
        <a class="xref" href="alter-table.html" title="13.1.7. ALTER TABLE Syntax">Section 13.1.7, “<code class="literal">ALTER TABLE</code> Syntax”</a>.
    </p><p>
        To see what indexes a table has, use <code class="literal">SHOW INDEX
        FROM <em class="replaceable"><code>tbl_name</code></em></code>.
    </p></li><li class="listitem"><p><a name="explain_key"></a>
        <code class="literal">key</code>
    </p><p>
        The <code class="literal">key</code> column indicates the key (index)
        that MySQL actually decided to use. If MySQL decides to use
        one of the <code class="literal">possible_keys</code> indexes to look
        up rows, that index is listed as the key value.
    </p><p>
        It is possible that <code class="literal">key</code> will name an
        index that is not present in the
        <code class="literal">possible_keys</code> value. This can happen if
        none of the <code class="literal">possible_keys</code> indexes are
        suitable for looking up rows, but all the columns selected
        by the query are columns of some other index. That is, the
        named index covers the selected columns, so although it is
        not used to determine which rows to retrieve, an index scan
        is more efficient than a data row scan.
    </p><p>
        For <code class="literal">InnoDB</code>, a secondary index might cover
        the selected columns even if the query also selects the
        primary key because <code class="literal">InnoDB</code> stores the
        primary key value with each secondary index. If
        <code class="literal">key</code> is <code class="literal">NULL</code>, MySQL
        found no index to use for executing the query more
        efficiently.
    </p><p>
        To force MySQL to use or ignore an index listed in the
        <code class="literal">possible_keys</code> column, use <code class="literal">FORCE
        INDEX</code>, <code class="literal">USE INDEX</code>, or
        <code class="literal">IGNORE INDEX</code> in your query. See
        <a class="xref" href="index-hints.html" title="13.2.9.3. Index Hint Syntax">Section 13.2.9.3, “Index Hint Syntax”</a>.
    </p><p>
        For <code class="literal">MyISAM</code> and <code class="literal">NDB</code>
        tables, running <a class="link" href="analyze-table.html" title="13.7.2.1. ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
        helps the optimizer choose better indexes. For
        <code class="literal">NDB</code> tables, this also improves
        performance of distributed pushed-down joins. For
        <code class="literal">MyISAM</code> tables, <a class="link" href="myisamchk.html" title="4.6.3. myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
        --analyze</strong></span></a> does the same as
        <a class="link" href="analyze-table.html" title="13.7.2.1. ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>. See
        <a class="xref" href="myisam-table-maintenance.html" title="7.6. MyISAM Table Maintenance and Crash Recovery">Section 7.6, “<code class="literal">MyISAM</code> Table Maintenance and Crash Recovery”</a>.
    </p></li><li class="listitem"><p><a name="explain_key_len"></a>
        <code class="literal">key_len</code>
    </p><p>
        The <code class="literal">key_len</code> column indicates the length
        of the key that MySQL decided to use. The length is
        <code class="literal">NULL</code> if the <code class="literal">key</code> column
        says <code class="literal">NULL</code>. Note that the value of
        <code class="literal">key_len</code> enables you to determine how many
        parts of a multiple-part key MySQL actually uses.
    </p></li><li class="listitem"><p><a name="explain_ref"></a>
        <code class="literal">ref</code>
    </p><p>
        The <code class="literal">ref</code> column shows which columns or
        constants are compared to the index named in the
        <code class="literal">key</code> column to select rows from the table.
    </p></li><li class="listitem"><p><a name="explain_rows"></a>
        <code class="literal">rows</code>
    </p><p>
        The <code class="literal">rows</code> column indicates the number of
        rows MySQL believes it must examine to execute the query.
    </p><p>
        For <a class="link" href="innodb-storage-engine.html" title="14.3. The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, this number
        is an estimate, and may not always be exact.
    </p></li><li class="listitem"><p><a name="explain_filtered"></a>
        <code class="literal">filtered</code>
    </p><p>
        The <code class="literal">filtered</code> column indicates an
        estimated percentage of table rows that will be filtered by
        the table condition. That is, <code class="literal">rows</code> shows
        the estimated number of rows examined and
        <code class="literal">rows</code> × <code class="literal">filtered</code>
        / <code class="literal">100</code> shows the number of rows that will
        be joined with previous tables. This column is displayed if
        you use <a class="link" title="8.8.3. EXPLAIN EXTENDED Output Format"><code class="literal">EXPLAIN EXTENDED</code></a>.
    </p></li><li class="listitem"><p><a name="explain_extra"></a>
        <code class="literal">Extra</code>
    </p><p>
        This column contains additional information about how MySQL
        resolves the query. For descriptions of the different
        values, see
        <a class="link" href="#explain-extra-information" title="8.8.2.  ???TITLE??? Extra Information"><code class="literal">EXPLAIN</code>
            Extra Information</a>.
    </p></li></ul>
</div>
<h4><a name="explain-join-types"></a>
    <code class="literal">EXPLAIN</code> Join Types
</h4>
<p>
    The <code class="literal">type</code> column of
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output describes how
    tables are joined. The following list describes the join types,
    ordered from the best type to the worst:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="jointype_system"></a>
    <a class="indexterm" name="idp43240112"></a>

    <a class="indexterm" name="idp43241600"></a>

    <a class="indexterm" name="idp43243088"></a>

    <a class="link" href="#jointype_system"><code class="literal">system</code></a>
</p><p>
    The table has only one row (= system table). This is a
    special case of the <a class="link" href="#jointype_const"><code class="literal">const</code></a>
    join type.
</p></li><li class="listitem"><p><a name="jointype_const"></a>
    <a class="indexterm" name="idp43247792"></a>

    <a class="indexterm" name="idp43249280"></a>

    <a class="indexterm" name="idp43250768"></a>

    <a class="link" href="#jointype_const"><code class="literal">const</code></a>
</p><p>
    The table has at most one matching row, which is read at the
    start of the query. Because there is only one row, values
    from the column in this row can be regarded as constants by
    the rest of the optimizer.
    <a class="link" href="#jointype_const"><code class="literal">const</code></a> tables are very
    fast because they are read only once.
</p><p>
    <a class="link" href="#jointype_const"><code class="literal">const</code></a> is used when you
    compare all parts of a <code class="literal">PRIMARY KEY</code> or
    <code class="literal">UNIQUE</code> index to constant values. In the
    following queries, <em class="replaceable"><code>tbl_name</code></em> can
    be used as a <a class="link" href="#jointype_const"><code class="literal">const</code></a> table:
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>primary_key</code></em>=1;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>primary_key_part1</code></em>=1 AND <em class="replaceable"><code>primary_key_part2</code></em>=2;
</pre></li><li class="listitem"><p><a name="jointype_eq_ref"></a>
    <a class="indexterm" name="idp43262688"></a>

    <a class="indexterm" name="idp43264176"></a>

    <a class="link" href="#jointype_eq_ref"><code class="literal">eq_ref</code></a>
</p><p>
    One row is read from this table for each combination of rows
    from the previous tables. Other than the
    <a class="link" href="#jointype_system"><code class="literal">system</code></a> and
    <a class="link" href="#jointype_const"><code class="literal">const</code></a> types, this is the
    best possible join type. It is used when all parts of an
    index are used by the join and the index is a
    <code class="literal">PRIMARY KEY</code> or <code class="literal">UNIQUE NOT
    NULL</code> index.
</p><p>
    <a class="link" href="#jointype_eq_ref"><code class="literal">eq_ref</code></a> can be used for
    indexed columns that are compared using the
    <code class="literal">=</code> operator. The comparison value can be a
    constant or an expression that uses columns from tables that
    are read before this table. In the following examples, MySQL
    can use an <a class="link" href="#jointype_eq_ref"><code class="literal">eq_ref</code></a> join to
    process <em class="replaceable"><code>ref_table</code></em>:
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_ref"></a>
    <a class="indexterm" name="idp43281520"></a>

    <a class="indexterm" name="idp43282976"></a>

    <a class="link" href="#jointype_ref"><code class="literal">ref</code></a>
</p><p>
    All rows with matching index values are read from this table
    for each combination of rows from the previous tables.
    <a class="link" href="#jointype_ref"><code class="literal">ref</code></a> is used if the join
    uses only a leftmost prefix of the key or if the key is not
    a <code class="literal">PRIMARY KEY</code> or
    <code class="literal">UNIQUE</code> index (in other words, if the join
    cannot select a single row based on the key value). If the
    key that is used matches only a few rows, this is a good
    join type.
</p><p>
    <a class="link" href="#jointype_ref"><code class="literal">ref</code></a> can be used for
    indexed columns that are compared using the
    <code class="literal">=</code> or <code class="literal">&lt;=&gt;</code>
    operator. In the following examples, MySQL can use a
    <a class="link" href="#jointype_ref"><code class="literal">ref</code></a> join to process
    <em class="replaceable"><code>ref_table</code></em>:
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em> WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_fulltext"></a>
    <a class="indexterm" name="idp43302256"></a>

    <a class="indexterm" name="idp43303744"></a>

    <a class="link" href="#jointype_fulltext"><code class="literal">fulltext</code></a>
</p><p>
    The join is performed using a <code class="literal">FULLTEXT</code>
    index.
</p></li><li class="listitem"><p><a name="jointype_ref_or_null"></a>
    <a class="indexterm" name="idp43308272"></a>

    <a class="indexterm" name="idp43309760"></a>

    <a class="link" href="#jointype_ref_or_null"><code class="literal">ref_or_null</code></a>
</p><p>
    This join type is like
    <a class="link" href="#jointype_ref"><code class="literal">ref</code></a>, but with the
    addition that MySQL does an extra search for rows that
    contain <code class="literal">NULL</code> values. This join type
    optimization is used most often in resolving subqueries. In
    the following examples, MySQL can use a
    <a class="link" href="#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> join to
    process <em class="replaceable"><code>ref_table</code></em>:
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>key_column</code></em> IS NULL;
</pre><p>
    See <a class="xref" href="is-null-optimization.html" title="8.13.4. IS NULL Optimization">Section 8.13.4, “<code class="literal">IS NULL</code> Optimization”</a>.
</p></li><li class="listitem"><p><a name="jointype_index_merge"></a>
    <a class="indexterm" name="idp43320048"></a>

    <a class="indexterm" name="idp43321536"></a>

    <a class="link" href="#jointype_index_merge"><code class="literal">index_merge</code></a>
</p><p>
    This join type indicates that the Index Merge optimization
    is used. In this case, the <code class="literal">key</code> column in
    the output row contains a list of indexes used, and
    <code class="literal">key_len</code> contains a list of the longest
    key parts for the indexes used. For more information, see
    <a class="xref" href="index-merge-optimization.html" title="8.13.2. Index Merge Optimization">Section 8.13.2, “Index Merge Optimization”</a>.
</p></li><li class="listitem"><p><a name="jointype_unique_subquery"></a>
    <a class="indexterm" name="idp43327552"></a>

    <a class="indexterm" name="idp43329040"></a>

    <a class="link" href="#jointype_unique_subquery"><code class="literal">unique_subquery</code></a>
</p><p>
    This type replaces <a class="link" href="#jointype_ref"><code class="literal">ref</code></a>
    for some <code class="literal">IN</code> subqueries of the following
    form:
</p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>primary_key</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre><p>
    <a class="link" href="#jointype_unique_subquery"><code class="literal">unique_subquery</code></a> is just
    an index lookup function that replaces the subquery
    completely for better efficiency.
</p></li><li class="listitem"><p><a name="jointype_index_subquery"></a>
    <a class="indexterm" name="idp43338048"></a>

    <a class="indexterm" name="idp43339536"></a>

    <a class="link" href="#jointype_index_subquery"><code class="literal">index_subquery</code></a>
</p><p>
    This join type is similar to
    <a class="link" href="#jointype_unique_subquery"><code class="literal">unique_subquery</code></a>. It
    replaces <code class="literal">IN</code> subqueries, but it works for
    nonunique indexes in subqueries of the following form:
</p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>key_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre></li><li class="listitem"><p><a name="jointype_range"></a>
    <a class="indexterm" name="idp43347296"></a>

    <a class="indexterm" name="idp43348784"></a>

    <a class="link" href="#jointype_range"><code class="literal">range</code></a>
</p><p>
    Only rows that are in a given range are retrieved, using an
    index to select the rows. The <code class="literal">key</code> column
    in the output row indicates which index is used. The
    <code class="literal">key_len</code> contains the longest key part
    that was used. The <code class="literal">ref</code> column is
    <code class="literal">NULL</code> for this type.
</p><p>
    <a class="link" href="#jointype_range"><code class="literal">range</code></a> can be used when a
    key column is compared to a constant using any of the
    <a class="link" href="comparison-operators.html#operator_equal"><code class="literal">=</code></a>,
    <a class="link" href="comparison-operators.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
    <a class="link" href="comparison-operators.html#operator_greater-than"><code class="literal">&gt;</code></a>,
    <a class="link" href="comparison-operators.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
    <a class="link" href="comparison-operators.html#operator_less-than"><code class="literal">&lt;</code></a>,
    <a class="link" href="comparison-operators.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
    <a class="link" href="comparison-operators.html#operator_is-null"><code class="literal">IS NULL</code></a>,
    <a class="link" href="comparison-operators.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
    <a class="link" href="comparison-operators.html#operator_between"><code class="literal">BETWEEN</code></a>, or
    <a class="link" href="comparison-operators.html#function_in"><code class="literal">IN()</code></a> operators:
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> = 10;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> BETWEEN 10 and 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> IN (10,20,30);

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em> = 10 AND <em class="replaceable"><code>key_part2</code></em> IN (10,20,30);
</pre></li><li class="listitem"><p><a name="jointype_index"></a>
    <a class="indexterm" name="idp43370128"></a>

    <a class="indexterm" name="idp43371616"></a>

    <a class="link" href="#jointype_index"><code class="literal">index</code></a>
</p><p>
    The <code class="literal">index</code> join type is the same as
    <code class="literal">ALL</code>, except that the
    index tree is scanned. This occurs two ways:
</p>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            If the index is a covering index for the queries and can
            be used to satisfy all data required from the table,
            only the index tree is scanned. In this case, the
            <code class="literal">Extra</code> column says <code class="literal">Using
            index</code>. An index-only scan usually is faster
            than <code class="literal">ALL</code> because
            the size of the index usually is smaller than the table
            data.
        </p></li><li class="listitem"><p>
            A full table scan is performed using reads from the
            index to look up data rows in index order. <code class="literal">Uses
            index</code> does not appear in the
            <code class="literal">Extra</code> column.
        </p></li></ul>
    </div>
    <p>
        MySQL can use this join type when the query uses only
        columns that are part of a single index.
    </p></li><li class="listitem"><p><a name="jointype_all"></a>
    <a class="indexterm" name="idp43384016"></a>

    <a class="indexterm" name="idp43385472"></a>

    <code class="literal">ALL</code>
</p><p>
    A full table scan is done for each combination of rows from
    the previous tables. This is normally not good if the table
    is the first table not marked
    <a class="link" href="#jointype_const"><code class="literal">const</code></a>, and usually
    <span class="emphasis"><em>very</em></span> bad in all other cases. Normally,
    you can avoid <code class="literal">ALL</code> by
    adding indexes that enable row retrieval from the table
    based on constant values or column values from earlier
    tables.
</p></li></ul>
</div>
<h4><a name="explain-extra-information"></a>
    <code class="literal">EXPLAIN</code> Extra Information
</h4>
<p>
    The <code class="literal">Extra</code> column of
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output contains
    additional information about how MySQL resolves the query. The
    following list explains the values that can appear in this
    column. If you want to make your queries as fast as possible,
    look out for <code class="literal">Extra</code> values of <code class="literal">Using
    filesort</code> and <code class="literal">Using temporary</code>.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
    <code class="literal">Child of '<em class="replaceable"><code>table</code></em>' pushed
        join@1</code>
</p><p>
    This table is referenced as the child of
    <em class="replaceable"><code>table</code></em> in a join that can be
    pushed down to the NDB kernel. Applies only in MySQL Cluster
    NDB 7.2 and later, when pushed-down joins are enabled. See
    the description of the
    <a class="link" href="mysql-cluster-system-variables.html#sysvar_ndb_join_pushdown"><code class="literal">ndb_join_pushdown</code></a> server
    system variable for more information and examples.
</p></li><li class="listitem"><p>
    <code class="literal">const row not found</code>
</p><p>
    For a query such as <code class="literal">SELECT ... FROM
    <em class="replaceable"><code>tbl_name</code></em></code>, the table was
    empty.
</p></li><li class="listitem"><p>
    <code class="literal">Distinct</code>
</p><p>
    MySQL is looking for distinct values, so it stops searching
    for more rows for the current row combination after it has
    found the first matching row.
</p></li><li class="listitem"><p>
    <code class="literal">Full scan on NULL key</code>
</p><p>
    This occurs for subquery optimization as a fallback strategy
    when the optimizer cannot use an index-lookup access method.
</p></li><li class="listitem"><p>
    <code class="literal">Impossible HAVING</code>
</p><p>
    The <code class="literal">HAVING</code> clause is always false and
    cannot select any rows.
</p></li><li class="listitem"><p>
    <code class="literal">Impossible WHERE</code>
</p><p>
    The <code class="literal">WHERE</code> clause is always false and
    cannot select any rows.
</p></li><li class="listitem"><p>
    <code class="literal">Impossible WHERE noticed after reading const
        tables</code>
</p><p>
    MySQL has read all <a class="link" href="#jointype_const"><code class="literal">const</code></a>
    (and <a class="link" href="#jointype_system"><code class="literal">system</code></a>) tables and
    notice that the <code class="literal">WHERE</code> clause is always
    false.
</p></li><li class="listitem"><p>
    <code class="literal">No matching min/max row</code>
</p><p>
    No row satisfies the condition for a query such as
    <code class="literal">SELECT MIN(...) FROM ... WHERE
        <em class="replaceable"><code>condition</code></em></code>.
</p></li><li class="listitem"><p>
    <code class="literal">no matching row in const table</code>
</p><p>
    For a query with a join, there was an empty table or a table
    with no rows satisfying a unique index condition.
</p></li><li class="listitem"><p>
    <code class="literal">No tables used</code>
</p><p>
    The query has no <code class="literal">FROM</code> clause, or has a
    <code class="literal">FROM DUAL</code> clause.
</p></li><li class="listitem"><p>
    <code class="literal">Not exists</code>
</p><p>
    MySQL was able to do a <code class="literal">LEFT JOIN</code>
    optimization on the query and does not examine more rows in
    this table for the previous row combination after it finds
    one row that matches the <code class="literal">LEFT JOIN</code>
    criteria. Here is an example of the type of query that can
    be optimized this way:
</p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;</pre><p>
    Assume that <code class="literal">t2.id</code> is defined as
    <code class="literal">NOT NULL</code>. In this case, MySQL scans
    <code class="literal">t1</code> and looks up the rows in
    <code class="literal">t2</code> using the values of
    <code class="literal">t1.id</code>. If MySQL finds a matching row in
    <code class="literal">t2</code>, it knows that
    <code class="literal">t2.id</code> can never be
    <code class="literal">NULL</code>, and does not scan through the rest
    of the rows in <code class="literal">t2</code> that have the same
    <code class="literal">id</code> value. In other words, for each row in
    <code class="literal">t1</code>, MySQL needs to do only a single
    lookup in <code class="literal">t2</code>, regardless of how many rows
    actually match in <code class="literal">t2</code>.
</p></li><li class="listitem"><p>
    <code class="literal">Range checked for each record (index map:
        <em class="replaceable"><code>N</code></em>)</code>
</p><p>
    MySQL found no good index to use, but found that some of
    indexes might be used after column values from preceding
    tables are known. For each row combination in the preceding
    tables, MySQL checks whether it is possible to use a
    <a class="link" href="#jointype_range"><code class="literal">range</code></a> or
    <a class="link" href="#jointype_index_merge"><code class="literal">index_merge</code></a> access method
    to retrieve rows. This is not very fast, but is faster than
    performing a join with no index at all. The applicability
    criteria are as described in
    <a class="xref" href="range-optimization.html" title="8.13.1. Range Optimization">Section 8.13.1, “Range Optimization”</a>, and
    <a class="xref" href="index-merge-optimization.html" title="8.13.2. Index Merge Optimization">Section 8.13.2, “Index Merge Optimization”</a>, with the
    exception that all column values for the preceding table are
    known and considered to be constants.
</p><p>
    Indexes are numbered beginning with 1, in the same order as
    shown by <a class="link" href="show-index.html" title="13.7.5.23. SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> for the
    table. The index map value <em class="replaceable"><code>N</code></em> is a
    bitmask value that indicates which indexes are candidates.
    For example, a value of <code class="literal">0x19</code> (binary
    11001) means that indexes 1, 4, and 5 will be considered.
</p></li><li class="listitem"><p>
    <code class="literal">Scanned <em class="replaceable"><code>N</code></em>
        databases</code>
</p><p>
    This indicates how many directory scans the server performs
    when processing a query for
    <code class="literal">INFORMATION_SCHEMA</code> tables, as described
    in <a class="xref" href="information-schema-optimization.html" title="8.2.4. Optimizing INFORMATION_SCHEMA Queries">Section 8.2.4, “Optimizing <code class="literal">INFORMATION_SCHEMA</code> Queries”</a>. The
    value of <em class="replaceable"><code>N</code></em> can be 0, 1, or
    <code class="literal">all</code>.
</p></li><li class="listitem"><p>
    <code class="literal">Select tables optimized away</code>
</p><p>
    The query contained only aggregate functions
    (<a class="link" href="group-by-functions.html#function_min"><code class="literal">MIN()</code></a>,
    <a class="link" href="group-by-functions.html#function_max"><code class="literal">MAX()</code></a>) that were all resolved
    using an index, or <a class="link" href="group-by-functions.html#function_count"><code class="literal">COUNT(*)</code></a>
    for <code class="literal">MyISAM</code>, and no <code class="literal">GROUP
    BY</code> clause. The optimizer determined that only one
    row should be returned.
</p></li><li class="listitem"><p>
    <code class="literal">Skip_open_table</code>,
    <code class="literal">Open_frm_only</code>,
    <code class="literal">Open_trigger_only</code>,
    <code class="literal">Open_full_table</code>
</p><p>
    These values indicate file-opening optimizations that apply
    to queries for <code class="literal">INFORMATION_SCHEMA</code> tables,
    as described in
    <a class="xref" href="information-schema-optimization.html" title="8.2.4. Optimizing INFORMATION_SCHEMA Queries">Section 8.2.4, “Optimizing <code class="literal">INFORMATION_SCHEMA</code> Queries”</a>.
</p>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">Skip_open_table</code>: Table files do not
            need to be opened. The information has already become
            available within the query by scanning the database
            directory.
        </p></li><li class="listitem"><p>
            <code class="literal">Open_frm_only</code>: Only the table's
            <code class="filename">.frm</code> file need be opened.
        </p></li><li class="listitem"><p>
            <code class="literal">Open_trigger_only</code>: Only the table's
            <code class="filename">.TRG</code> file need be opened.
        </p></li><li class="listitem"><p>
            <code class="literal">Open_full_table</code>: The unoptimized
            information lookup. The <code class="filename">.frm</code>,
            <code class="filename">.MYD</code>, and <code class="filename">.MYI</code>
            files must be opened.
        </p></li></ul>
    </div>
</li><li class="listitem"><p>
    <code class="literal">unique row not found</code>
</p><p>
    For a query such as <code class="literal">SELECT ... FROM
    <em class="replaceable"><code>tbl_name</code></em></code>, no rows
    satisfy the condition for a <code class="literal">UNIQUE</code> index
    or <code class="literal">PRIMARY KEY</code> on the table.
</p></li><li class="listitem"><p>
    <code class="literal">Using filesort</code>
</p><p>
    MySQL must do an extra pass to find out how to retrieve the
    rows in sorted order. The sort is done by going through all
    rows according to the join type and storing the sort key and
    pointer to the row for all rows that match the
    <code class="literal">WHERE</code> clause. The keys then are sorted
    and the rows are retrieved in sorted order. See
    <a class="xref" href="order-by-optimization.html" title="8.13.9. ORDER BY Optimization">Section 8.13.9, “<code class="literal">ORDER BY</code> Optimization”</a>.
</p></li><li class="listitem"><p>
    <code class="literal">Using index</code>
</p><p>
    The column information is retrieved from the table using
    only information in the index tree without having to do an
    additional seek to read the actual row. This strategy can be
    used when the query uses only columns that are part of a
    single index.
</p><p>
    If the <code class="literal">Extra</code> column also says
    <code class="literal">Using where</code>, it means the index is being
    used to perform lookups of key values. Without
    <code class="literal">Using where</code>, the optimizer may be reading
    the index to avoid reading data rows but not using it for
    lookups. For example, if the index is a covering index for
    the query, the optimizer may scan it without using it for
    lookups.
</p><p>
    For <code class="literal">InnoDB</code> tables that have a
    user-defined clustered index, that index can be used even
    when <code class="literal">Using index</code> is absent from the
    <code class="literal">Extra</code> column. This is the case if
    <code class="literal">type</code> is
    <a class="link" href="#jointype_index"><code class="literal">index</code></a> and
    <code class="literal">key</code> is <code class="literal">PRIMARY</code>.
</p></li><li class="listitem"><p>
    <code class="literal">Using index for group-by</code>
</p><p>
    Similar to the <code class="literal">Using index</code> table access
    method, <code class="literal">Using index for group-by</code>
    indicates that MySQL found an index that can be used to
    retrieve all columns of a <code class="literal">GROUP BY</code> or
    <code class="literal">DISTINCT</code> query without any extra disk
    access to the actual table. Additionally, the index is used
    in the most efficient way so that for each group, only a few
    index entries are read. For details, see
    <a class="xref" href="group-by-optimization.html" title="8.13.10. GROUP BY Optimization">Section 8.13.10, “<code class="literal">GROUP BY</code> Optimization”</a>.
</p></li><li class="listitem"><p>
    <code class="literal">Using join buffer</code>
</p><p>
    Tables from earlier joins are read in portions into the join
    buffer, and then their rows are used from the buffer to
    perform the join with the current table.
</p></li><li class="listitem"><p>
    <code class="literal">Using sort_union(...)</code>, <code class="literal">Using
    union(...)</code>, <code class="literal">Using
    intersect(...)</code>
</p><p>
    These indicate how index scans are merged for the
    <a class="link" href="#jointype_index_merge"><code class="literal">index_merge</code></a> join type.
    See <a class="xref" href="index-merge-optimization.html" title="8.13.2. Index Merge Optimization">Section 8.13.2, “Index Merge Optimization”</a>.
</p></li><li class="listitem"><p>
    <code class="literal">Using temporary</code>
</p><p>
    To resolve the query, MySQL needs to create a temporary
    table to hold the result. This typically happens if the
    query contains <code class="literal">GROUP BY</code> and
    <code class="literal">ORDER BY</code> clauses that list columns
    differently.
</p></li><li class="listitem"><p>
    <code class="literal">Using where</code>
</p><p>
    A <code class="literal">WHERE</code> clause is used to restrict which
    rows to match against the next table or send to the client.
    Unless you specifically intend to fetch or examine all rows
    from the table, you may have something wrong in your query
    if the <code class="literal">Extra</code> value is not <code class="literal">Using
    where</code> and the table join type is
    <code class="literal">ALL</code> or
    <a class="link" href="#jointype_index"><code class="literal">index</code></a>. Even if you are
    using an index for all parts of a <code class="literal">WHERE</code>
    clause, you may see <code class="literal">Using where</code> if the
    column can be <code class="literal">NULL</code>.
</p></li><li class="listitem"><p>
    <code class="literal">Using where with pushed condition</code>
</p><p>
    This item applies to <a class="link" href="mysql-cluster.html" title="Chapter 17. MySQL Cluster NDB 7.2"><code class="literal">NDBCLUSTER</code></a>
    tables <span class="emphasis"><em>only</em></span>. It means that MySQL
    Cluster is using the Condition Pushdown optimization to
    improve the efficiency of a direct comparison between a
    nonindexed column and a constant. In such cases, the
    condition is <span class="quote">“<span class="quote">pushed down</span>”</span> to the cluster's
    data nodes and is evaluated on all data nodes
    simultaneously. This eliminates the need to send nonmatching
    rows over the network, and can speed up such queries by a
    factor of 5 to 10 times over cases where Condition Pushdown
    could be but is not used. For more information, see
    <a class="xref" href="condition-pushdown-optimization.html" title="8.13.3. Engine Condition Pushdown Optimization">Section 8.13.3, “Engine Condition Pushdown Optimization”</a>.
</p></li></ul>
</div>
<h4><a name="explain-output-interpretation"></a>
    <code class="literal">EXPLAIN</code> Output Interpretation
</h4>
<p>
    You can get a good indication of how good a join is by taking
    the product of the values in the <code class="literal">rows</code> column
    of the <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output. This
    should tell you roughly how many rows MySQL must examine to
    execute the query. If you restrict queries with the
    <a class="link" href="server-system-variables.html#sysvar_max_join_size"><code class="literal">max_join_size</code></a> system variable,
    this row product also is used to determine which multiple-table
    <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statements to execute and
    which to abort. See <a class="xref" href="server-parameters.html" title="8.11.2. Tuning Server Parameters">Section 8.11.2, “Tuning Server Parameters”</a>.
</p><p>
    The following example shows how a multiple-table join can be
    optimized progressively based on the information provided by
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>.
</p><p>
    Suppose that you have the <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
    statement shown here and that you plan to examine it using
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>:
</p><pre class="programlisting">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;</pre><p>
    For this example, make the following assumptions:
</p>
<div class="itemizedlist">
    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        The columns being compared have been declared as follows.
    </p>
        <div class="informaltable">
            <table summary="This table outlines table names, column names, and
              data types for the columns being compared in the
              EXPLAIN example described in the
preceding text." border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">Table</th><th scope="col">Column</th><th scope="col">Data Type</th></tr></thead><tbody><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code></td><td><code class="literal">CHAR(15)</code></td></tr><tr><td scope="row"><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code></td><td><code class="literal">CHAR(15)</code></td></tr></tbody></table>
        </div>
    </li><li class="listitem"><p>
        The tables have the following indexes.
    </p>
        <div class="informaltable">
            <table summary="This table lists indexes for each of the tables
              that are part of the EXPLAIN example
described in the preceding text." border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Table</th><th scope="col">Index</th></tr></thead><tbody><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td></tr><tr><td scope="row"><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code> (primary key)</td></tr><tr><td scope="row"><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code> (primary key)</td></tr></tbody></table>
        </div>
    </li><li class="listitem"><p>
        The <code class="literal">tt.ActualPC</code> values are not evenly
        distributed.
    </p></li></ul>
</div>
<p>
    Initially, before any optimizations have been performed, the
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement produces the
    following information:
</p><pre class="programlisting">table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)</pre><p>
    Because <code class="literal">type</code> is
    <code class="literal">ALL</code> for each table, this
    output indicates that MySQL is generating a Cartesian product of
    all the tables; that is, every combination of rows. This takes
    quite a long time, because the product of the number of rows in
    each table must be examined. For the case at hand, this product
    is 74 × 2135 × 74 × 3872 = 45,268,558,720
    rows. If the tables were bigger, you can only imagine how long
    it would take.
</p><p>
    One problem here is that MySQL can use indexes on columns more
    efficiently if they are declared as the same type and size. In
    this context, <a class="link" href="char.html" title="11.4.1. The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> and
    <a class="link" href="char.html" title="11.4.1. The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> are considered the same if
    they are declared as the same size.
    <code class="literal">tt.ActualPC</code> is declared as
    <code class="literal">CHAR(10)</code> and <code class="literal">et.EMPLOYID</code>
    is <code class="literal">CHAR(15)</code>, so there is a length mismatch.
</p><p>
    To fix this disparity between column lengths, use
    <a class="link" href="alter-table.html" title="13.1.7. ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to lengthen
    <code class="literal">ActualPC</code> from 10 characters to 15 characters:
</p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</code></strong>
</pre><p>
    Now <code class="literal">tt.ActualPC</code> and
    <code class="literal">et.EMPLOYID</code> are both
    <code class="literal">VARCHAR(15)</code>. Executing the
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement again produces
    this result:
</p><pre class="programlisting">table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1</pre><p>
    This is not perfect, but is much better: The product of the
    <code class="literal">rows</code> values is less by a factor of 74. This
    version executes in a couple of seconds.
</p><p>
    A second alteration can be made to eliminate the column length
    mismatches for the <code class="literal">tt.AssignedPC =
    et_1.EMPLOYID</code> and <code class="literal">tt.ClientID =
    do.CUSTNMBR</code> comparisons:
</p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</code></strong>
    -&gt;                <strong class="userinput"><code>MODIFY ClientID   VARCHAR(15);</code></strong>
</pre><p>
    After that modification, <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
    produces the output shown here:
</p><pre class="programlisting">table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1</pre><p>
    At this point, the query is optimized almost as well as
    possible. The remaining problem is that, by default, MySQL
    assumes that values in the <code class="literal">tt.ActualPC</code> column
    are evenly distributed, and that is not the case for the
    <code class="literal">tt</code> table. Fortunately, it is easy to tell
    MySQL to analyze the key distribution:
</p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE tt;</code></strong>
</pre><p>
    With the additional index information, the join is perfect and
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces this result:
</p><pre class="programlisting">table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1</pre><p>
    <a class="indexterm" name="idp43607792"></a>

    Note that the <code class="literal">rows</code> column in the output from
    <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is an educated guess from
    the MySQL join optimizer. Check whether the numbers are even
    close to the truth by comparing the <code class="literal">rows</code>
    product with the actual number of rows that the query returns.
    If the numbers are quite different, you might get better
    performance by using <code class="literal">STRAIGHT_JOIN</code> in your
    <a class="link"  title="13.2.9. SELECT Syntax"><code class="literal">SELECT</code></a> statement and trying to
    list the tables in a different order in the
    <code class="literal">FROM</code> clause.
</p><p>
    It is possible in some cases to execute statements that modify
    data when <a class="link" title="13.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN
    SELECT</code></a> is used with a subquery; for more information,
    see <a class="xref" href="from-clause-subqueries.html" title="13.2.10.8. Subqueries in the FROM Clause">Section 13.2.10.8, “Subqueries in the <code class="literal">FROM</code> Clause”</a>.
</p>